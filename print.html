<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rubik Project</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="prologue.html">Prologue</a></li><li class="chapter-item expanded affix "><a href="resources.html">Resources</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">2.</strong> Compatibility with Go stdlib</a></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">3.</strong> Commanding your Workspace</a></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">4.</strong> Rubik Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="components/guards.html"><strong aria-hidden="true">4.1.</strong> Guards</a></li><li class="chapter-item expanded "><a href="components/assertions.html"><strong aria-hidden="true">4.2.</strong> Assertions</a></li><li class="chapter-item expanded "><a href="components/middlewares.html"><strong aria-hidden="true">4.3.</strong> Middlewares</a></li><li class="chapter-item expanded "><a href="components/entity.html"><strong aria-hidden="true">4.4.</strong> Entity</a></li><li class="chapter-item expanded "><a href="components/controllers.html"><strong aria-hidden="true">4.5.</strong> Controllers</a></li><li class="chapter-item expanded "><a href="lifecycle.html"><strong aria-hidden="true">4.6.</strong> Lifecycle of Rubik</a></li></ol></li><li class="chapter-item expanded "><a href="blocks.html"><strong aria-hidden="true">5.</strong> Blocks: Runtime Extensions</a></li><li class="chapter-item expanded "><a href="changelog.html"><strong aria-hidden="true">6.</strong> Changelog</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Rubik Project</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#prologue" id="prologue">Prologue</a></h1>
<p>Rubik aims to be a fast, scalable and productive Web framework for Go, by composing pre-built
blocks of code to fasten the development process. It offers:</p>
<ol>
<li>🟢 Writing server-side code for faster backend development using <code>gen</code> command.</li>
<li>🟡 Generating client SDKs for your backend on the fly for better/fast integration of frontends.</li>
<li>🔵 Debugging your APIs quicker with Rubik REPL.</li>
<li>🟡 Communication between services with it's own Messaging Passing layer and includes Event-Driven Development.</li>
</ol>
<p>Rubik has a robust/thin layer of Go's reflection <em>(which is optional)</em> supporting the whole framework and provide many simple
high-level APIs for handling complex tasks. The directory structure of Rubik is minimal and effective.</p>
<h2><a class="header" href="#why-rubik" id="why-rubik">Why Rubik?</a></h2>
<p>Rubik Framework for Go is a part of &quot;Rubik Project&quot; which was started in light of use-cases where you want stability and speed in creating your ideas and making it to life as quick as possible. It provides with a layer of abstraction so you don't steer far away from Go's standard library and use great tools to get you started with web development in Go.</p>
<p>If you are new to Go and want to create a web app easily and quickly with familiar architecture as most frameworks from different languages Rubik is the best way to create your app.</p>
<h2><a class="header" href="#is-rubik-stable" id="is-rubik-stable">Is Rubik stable?</a></h2>
<p>No, currently <strong>it is not!</strong>. The implementation of this project is being done in such a way that
you will not have to think about anything while implementing your ideas. It should feel natural
just to use <a href="blocks.html">Blocks</a> and inbuilt tools while working on your ideas and <em>&quot;Rubik is not
there yet.&quot;</em> But it is stable enough to quickly create prototypes of your ideas.</p>
<h2><a class="header" href="#how-can-you-help-rubik-project" id="how-can-you-help-rubik-project">How can you help Rubik Project?</a></h2>
<ol>
<li>You can help Rubik Project by trying it out and helping us fix bugs as quickly as possible to make
this project stable.</li>
<li>Contributing with Pull Requests with potential fixes and features.</li>
<li>You can make this project sustainable by donating us to make Rubik more of a main and serious
attempt to create a framework that is <em>&quot;fast, flexible and solid&quot;</em>, instead of this being developed in our spare time.</li>
</ol>
<h2><a class="header" href="#goals" id="goals">Goals</a></h2>
<ul>
<li>Keep a small core</li>
<li>Support Extensions</li>
<li>Simple and Descriptive with structural composition instead of functional</li>
<li>Extensive tooling and Automation with projects that blends well with the Rubik ecosystem</li>
<li>Avoid Repitition of common logic, <em>&quot;if one of us develops a foreign implementation it should
be for all of us&quot;</em></li>
</ul>
<h3><a class="header" href="#indicators" id="indicators">Indicators</a></h3>
<p>🟢 Solid 🟡 Flaky 🔵 Implementation Undecided</p>
<h1><a class="header" href="#-resources" id="-resources">📺 Resources</a></h1>
<p>This topic holds the culmunation of guides, docs, and videos about Rubik. Since Rubik is an young project yet
to set foot on production you will always have a lack of resources and places to look for Projects.</p>
<p>Below are some list of resources to browse through or watch:</p>
<table><thead><tr><th>Type</th><th>Purpose</th><th>URL</th></tr></thead><tbody>
<tr><td>Video</td><td>First Rubik Demo <em>(gives you a general idea on the ethos of the framework)</em></td><td><a href="https://youtu.be/bUx066QTwfE">Link</a></td></tr>
<tr><td>Doc</td><td>GoDoc of Rubik</td><td><a href="https://pkg.go.dev/github.com/rubikorg/rubik?tab=doc">Link</a></td></tr>
</tbody></table>
<p>You can also follow my <a href="https://www.youtube.com/channel/UCLwgNn_4JnAG7UuO6klY2nQ">YouTube channel</a> for upcoming content and implementation of Rubik Framework to get a grasp.</p>
<h1><a class="header" href="#-getting-started" id="-getting-started">📓 Getting Started</a></h1>
<p>Before you can use Rubik you need to make sure that development environment is up-to-date and ensure that everything is
setup correctly. Let's go throught the requirements of Rubik first.</p>
<h2><a class="header" href="#install-go" id="install-go">Install Go</a></h2>
<p>Rubik Framework is written using Go programming language but you'll need Go runtime to execute your Rubik server. The
<a href="https://golang.org/doc/install">official Go installation</a> guide provides you with a step by step instruction to install <code>Go</code>.</p>
<p>Testing your Go installation:</p>
<pre><code class="language-bash"># this command outputs the version of Go runtime that you have installed
go version
</code></pre>
<h2><a class="header" href="#installing-okrubik" id="installing-okrubik">Installing okrubik</a></h2>
<p>Rubik CLI helps you in being productive and accomplish your tasks with ease. It has some really nice advantages over
normal execution that is <a href="/blog/rubik-commands">discussed here</a>.</p>
<p><span style="font-weight: bold">Shell</span>:</p>
<pre><code class="language-bash">curl https://rubik.ashishshekar.com/install | sh
</code></pre>
<p>Thie CLI will be downloaded and installed under <code>$HOME/.rubik/bin</code> folder. You need to add this path to your
<code>bash_profile</code> or it's equivalents:</p>
<pre><code class="language-bash"># example
nano ~/.bash_profile
# add the below line to the end of the file
export PATH=&quot;$HOME/.rubik/bin:$PATH&quot;
</code></pre>
<p>Now let's check if the installation was successful. Run:</p>
<pre><code class="language-bash">okrubik

# Welcome to Rubik Command-Line Manager use --help for help text
</code></pre>
<p>You have just set-up your development environment like a boss. You are ready to <code>Go!!</code>.</p>
<h2><a class="header" href="#generating-a-new-rubik-project" id="generating-a-new-rubik-project">Generating a New Rubik Project</a></h2>
<p>In this tutorial you'll learn how to setup your Rubik project using the command-line generator and how easy
it is to setup a productive environment with Rubik.</p>
<p>In the previous tutorial we installed <code>okrubik</code> a CLI for this framework, to ensure that it is installed run:</p>
<pre><code class="language-bash">okrubik help
</code></pre>
<p>which outputs the following help text for all the commands available in Rubik.</p>
<pre><code>Rubik is an efficient web framework for Go that encapsulates
common tasks and functions and provides ease of REST API development.

Complete documentation is available at https://rubikorg.github.io

Usage:
  okrubik [flags]
  okrubik [command]

Available Commands:
  bundle      Create/Manage release bundle of your Rubik service
  exec        Execute a rubik command defined inside rubik.toml under [x] object
  gen         Generates project code for your Rubik server
  help        Help about any command
  new         Create a new Rubik project
  run         Runs the app created under this workspace
  upgrade     Upgrade the project dependencies or upgrade self

Flags:
  -h, --help   help for okrubik

Use &quot;okrubik [command] --help&quot; for more information about a command.
</code></pre>
<pre><code class="language-bash">okrubik new helloworld
</code></pre>
<p>You'll have a new directory called <code>helloworld</code> now and will consists of Rubik project files.
Let's run the server by running:</p>
<pre><code class="language-bash">okrubik run -a server
</code></pre>
<p>The <code>-a</code> flag accepts a name of the application in our case, the default <code>server</code> as the argument. If you have multiple server projects under the same workspace you can do <code>okrubik run</code> which shows a dynamic CLI selection of the list of your Rubik servers which we will take a look at in this <a href="/chapter_4.html">chapter</a>.</p>
<h3><a class="header" href="#viewing-server" id="viewing-server">Viewing server</a></h3>
<p>Now let's visit <a href="http://localhost:7000">localhost:7000</a>. Wew! Our Rubik project is all set-up in just
under a minute. This is a great start!</p>
<h1><a class="header" href="#-compatibility-with-go-stdlib" id="-compatibility-with-go-stdlib">💟 Compatibility with Go stdlib</a></h1>
<p>If you have developed your applications using the <code>net/http</code> package and want to use Handlers as
Rubik's route controller, it can be easily migrated to <a href="">Controller</a> type in Rubik using simple
conversion methods. The middlewares which are also generally <a href="">http.Handler</a> or
<a href="">http.HandlerFunc</a> types can be migrated as well.</p>
<h2><a class="header" href="#converting-httphandler" id="converting-httphandler">Converting http.Handler</a></h2>
<p>To convert a http.Handler into rubik.Controller you can use <code>UseHandler()</code> which accepts a Handler
as an input and returns a Controller. It can be inlined during Route declaration like so.</p>
<pre><code class="language-go">import (
    &quot;net/http&quot;
    r &quot;github.com/rubikorg/rubik&quot;
)

type MyHandler {}

func (MyHandler) ServeHTTP(req *http.Request, writer *http.ResponseWriter) {
    // your code
}

var myRoute = r.Route{
    Path: &quot;/mypath&quot;,
    Controller: r.UseHandler(MyHandler{}),
}
</code></pre>
<h2><a class="header" href="#converting-httphandlerfunc" id="converting-httphandlerfunc">Converting http.HandlerFunc</a></h2>
<p>To migrate/use your old http.HandlerFunc you can use <code>UseHandlerFunc()</code> which accepts a HandlerFunc
and returns Controller. It can also be inlined.</p>
<pre><code class="language-go">import (
    &quot;net/http&quot;
    r &quot;github.com/rubikorg/rubik&quot;
)

func myHandlerFunc(req *http.Request, writer *http.ResponseWriter) {
    // your code
}

var myRoute = r.Route{
    Path: &quot;/mypath&quot;,
    Controller: r.UseHandlerFunc(myHandlerFunc),
}
</code></pre>
<h2><a class="header" href="#using-stdlib-handlers" id="using-stdlib-handlers">Using <code>stdlib</code> Handlers</a></h2>
<p>Middlewares in Rubik are just Controller type. Using the above two methods you can generally use
most of the Handler and HandlerFunc's designed for <code>stdlib</code> in your Rubik project but some
middlewares has made a design choice of using intermediate handler functions such as
<a href="https://github.com/rs/cors">CORS</a> handler. To use such functions there is a helper method called
<code>UseIntermHandler()</code> which takes in <code>func(http.Handler) http.Handler</code> type and returns a Rubik
Controller.</p>
<p>Example:</p>
<pre><code class="language-go">import (
    &quot;github.com/rs/cors&quot;
    r &quot;github.com/rubikorg/rubik&quot;
)

var c = cors.New(cors.Options{
    AllowedOrigins: []string{&quot;http://foo.com&quot;, &quot;http://foo.com:8080&quot;},
    AllowCredentials: true,
    Debug: true,
})

var myRoute = r.Route{
    Path: &quot;/mypath&quot;,
    Middlewares: r.Middleware{
        r.UseIntermHandler(c.Handler),
    },
    Controller: myCtl,
}
</code></pre>
<h1><a class="header" href="#-commanding-your-workspace" id="-commanding-your-workspace">⌨️ Commanding your Workspace</a></h1>
<p>Rubik comes with a lot of useful commands that makes web development easy in Go, in this chapter we are going to take a look at <code>okrubik</code> CLI's commands and how you can configure your workspace.</p>
<h3><a class="header" href="#workspace-configuration" id="workspace-configuration">Workspace Configuration</a></h3>
<p>The configuration of your workspace in Rubik is done using the <code>rubik.toml</code> file. Let's take a look at the default Rubik configuration file.</p>
<pre><code class="language-toml">name = &quot;okrubik&quot;
module = &quot;github.com/rubikorg/okrubik&quot;
flat = false
maxprocs = 0
log = false

[[app]]
  name = &quot;server&quot;
  path = &quot;./cmd/server&quot;
  watch = true
  communicate = false

[x]
  [x.test]
    command = &quot;go test -cover ./cmd/server/...&quot;
</code></pre>
<h3><a class="header" href="#create" id="create"><code>&gt; create</code></a></h3>
<p>The <code>create</code> command is used to create a new Rubik project. It downloads all the boilerplate code required to get a barebones version of Rubik server running. It creates a new folder with the project name provided. There are 2 ways to run this command.</p>
<p><strong>Interactive Mode</strong></p>
<pre><code class="language-bash">okrubik create
</code></pre>
<p><strong>Command Mode</strong></p>
<pre><code class="language-bash">okrubik create -n helloworld -m helloworld -p 4000
</code></pre>
<h3><a class="header" href="#gen" id="gen"><code>&gt; gen</code></a></h3>
<p><code>gen</code> command generates components for your Rubik projects. Currently it can generate 2 things:</p>
<ol>
<li>Binary</li>
</ol>
<pre><code class="language-bash">okrubik gen bin $binaryName
</code></pre>
<ol start="2">
<li>Router</li>
</ol>
<pre><code class="language-bash">okrubik gen router $routerName
</code></pre>
<h3><a class="header" href="#run" id="run"><code>&gt; run</code></a></h3>
<p><strong>Interactive Mode</strong></p>
<pre><code class="language-bash">okrubik run
</code></pre>
<p><strong>Command Mode</strong></p>
<pre><code class="language-bash">okrubik run -a $appName
</code></pre>
<h3><a class="header" href="#exec" id="exec"><code>&gt; exec</code></a></h3>
<p>The <code>exec</code> command runs your custom commands mentioned inside <code>rubik.toml</code>. As per our 1st topic, we can see this <code>x</code> object declaration.</p>
<pre><code class="language-toml">[x]
  [x.test]
    command = &quot;go test -cover ./cmd/server/...&quot;
</code></pre>
<p>This block of configuration has a <code>[x.test]</code> which can be run inside your workspace. Let's try it out, and add a command called <code>foo</code> which just writes foo to stdout.</p>
<pre><code class="language-toml">    [x.foo]
      command = &quot;echo foo&quot;
</code></pre>
<p>Now lets run this command using okrubik.</p>
<pre><code class="language-bash">okrubik x foo

# foo
</code></pre>
<p>The <code>x</code> is an alias for <code>exec</code> and you can see it outputs <code>foo</code> as it runs the command that is declared inside <code>[x.foo]</code>.</p>
<h1><a class="header" href="#-rubik-components" id="-rubik-components">🎹 Rubik Components</a></h1>
<p>In this chapter we will take a look at the components the Rubik Server is composed of. The components allow us to write code with less coupling and highly domain-driven code.</p>
<h3><a class="header" href="#component-list" id="component-list">Component List</a></h3>
<ol>
<li><a href="/components/guards.html">Guards</a></li>
<li><a href="/components/assertions.html">Assertions</a></li>
<li><a href="/components/middlewares.html">Middlewares</a></li>
<li><a href="/components/entity.html">Entity</a></li>
<li><a href="/components/controllers.html">Controllers</a></li>
</ol>
<h1><a class="header" href="#-guards" id="-guards">🚔 Guards</a></h1>
<p>Guards are rubik.Controller that &quot;guards&quot; your route from potentially bad/error-prone requests. As
you know that in Rubik every request is controlled/manipulated/processed by the
<code>rubik.Controller</code> type which you can read in <a href="components/./components/controllers.html">Section 4.5</a>.</p>
<p>There is no difference between a Middleware, Core request handler and Guards are nothing
different in case of function signature but the only difference is that, <strong><em>Guards run before
Assertions</em></strong>.</p>
<p>Let's say you want to reject any request that does not have the <code>x-rubik-client</code> header. Let's
write our guard.</p>
<h4><a class="header" href="#example-guard" id="example-guard">Example Guard</a></h4>
<pre><code class="language-go">func rejectNonRubikClients(req *rubik.Request) {
	if (req.Raw.Header.Get(&quot;x-rubik-client&quot;) == &quot;&quot;) {
		req.Throw(401, &quot;You are not authorized to access this API.&quot;, rubik.Type.JSON)
		return
	}
}
</code></pre>
<p>Adding this guard to any of your route.</p>
<pre><code class="language-go">var myRoute = rubik.Route{
	Guards: []Controller{rejectNonRubikClients},
	Path: &quot;/getMeSomething&quot;,
	Controller: myCtl,
}
</code></pre>
<p>In this case <code>myRoute</code> will reject any client with:</p>
<pre><code class="language-json">{
	&quot;code&quot;: 401,
	&quot;message&quot;: &quot;You are not authorized to access this API.&quot;
}
</code></pre>
<p>for any request with <code>x-rubik-client</code> header being empty.</p>
<h1><a class="header" href="#-assertions" id="-assertions">🔍 Assertions</a></h1>
<p>Assertions are used to validate and confirm that a value from the client/user is of the right type
and meets the requirements of your business needs. E.g: <code>email</code> value inside body must be of the
form of an email id and not any other type or structure.</p>
<blockquote>
<p><strong>Note:</strong></p>
<p>When assertions fail it responds with <code>400 (Bad Request)</code> with the assertion message provided by
you.</p>
</blockquote>
<h3><a class="header" href="#assertion-type" id="assertion-type">Assertion type:</a></h3>
<pre><code class="language-go">type Assertion func (interface{}) error
</code></pre>
<h3><a class="header" href="#writing-your-own-assertions" id="writing-your-own-assertions">Writing your own assertions:</a></h3>
<p>Let's write a simple assertion to check if the integer value equates to 0 or not:</p>
<pre><code class="language-go">func isZero(val interface{}) error {
	msg := &quot;$ does not equates to 0.&quot;
	switch val.(type) {
		case string:
			intval, err := strconv.Atoi(val)
			if err != nil {
				return errors.New(&quot;$ is not an integer value&quot;)
			}

			if intval != 0 {
				return errors.New(msg)
			}
			return nil
		case int:
			val != 0 {
				return errors.New(msg)
			}
			return nil
		default:
			return nil
	}
}
</code></pre>
<p><strong>Notice</strong> the <code>$</code> symbol, this is used to populate the name of the variable it is checking. As per
the above example if the <code>Threshold</code> cannot be converted to an integer the error message will be
<code>Threshold is not an integer value</code>.</p>
<h3><a class="header" href="#using-your-assertion" id="using-your-assertion">Using your assertion:</a></h3>
<pre><code class="language-go">type AddEn {
	Food 	string
	Threshold 	int
}

var addRoute = rubik.Route{
	Path: &quot;/add&quot;,
	Entity: AddEn{},
	Validations: rubik.Validation{
		&quot;Threshold&quot;: []rubik.Assertion{isZero},
	},
	Controller: addCtl,
}
</code></pre>
<h1><a class="header" href="#middlewares" id="middlewares">Middlewares</a></h1>
<p>In Rubik Middlewares are Controllers that run after your Assertions, meaning that they are just
Guards that postpone their executions until your Validations are done. Let's combine
<a href="components/./components/guards.html">Guards: Section 4.1</a> example and add a middleware to get to know them better.</p>
<p>From <a href="components/./components/guards.html#example-guard">Guards: Section 4.1</a> code we have this
<code>rubik.Controller</code>:</p>
<pre><code class="language-go">func rejectNonRubikClients(req *rubik.Request) {
	if (req.Raw.Header.Get(&quot;x-rubik-client&quot;) == &quot;&quot;) {
		req.Throw(401, &quot;You are not authorized to access this API.&quot;, rubik.Type.JSON)
		return
	}
}
</code></pre>
<h4><a class="header" href="#example-middleware" id="example-middleware">Example Middleware</a></h4>
<pre><code class="language-go">func checkAuthHeader(req *rubik.Request) {
	if (req.Raw.Header.Get(&quot;authorization&quot;) == &quot;&quot;) {
		req.Throw(401, &quot;Contact support!&quot;, rubik.Type.JSON)
		return
	}
}
</code></pre>
<p>Add it to the myRoute with validations:</p>
<pre><code class="language-go">type MyEntity struct{
	Name string
}

var myRoute = rubik.Route{
	Path: &quot;/getMeSomething&quot;
	Entity: MyEntity{},
	Guards: []rubik.Controller{rejectNonRubikClients},
	Validation: rubik.Validation{
		&quot;name&quot;: []rubik.Assertion{checker.StrIsOneOf(&quot;tom&quot;, &quot;jerry&quot;)},
	},
	Middlewares: []rubik.Controller{checkAuthHeader},
}
// replace myRouter with Router of your choice
[myRouter].Add(myRoute)
</code></pre>
<p>Lets <strong>cURL</strong> it:</p>
<pre><code class="language-bash">curl -H &quot;authotization: Basic hi&quot; &quot;http://localhost:$PORT/getMeSomething?name=tom&quot;
</code></pre>
<blockquote>
<p><strong>Response</strong></p>
</blockquote>
<pre><code class="language-json">{
	&quot;code&quot;: 401,
	&quot;message&quot;: &quot;You are not authorized to access this API.&quot;
}
</code></pre>
<pre><code class="language-bash">curl -H &quot;x-rubik-client: clientToken&quot; &quot;http://localhost:$PORT/getMeSomething?name=tom&quot;
</code></pre>
<blockquote>
<p><strong>Response</strong></p>
</blockquote>
<pre><code class="language-json">{
	&quot;code&quot;: 401,
	&quot;message&quot;: &quot;Contact support!&quot;
}
</code></pre>
<h1><a class="header" href="#entity" id="entity">Entity</a></h1>
<p>Entity in Rubik specifies the requirements for your target route to function. Specifying your
requirements explicitely comes with a lot of advantages. Let's try to specify an entity.</p>
<pre><code class="language-go">type MyEntity struct {
	Name string
}
</code></pre>
<p><code>MyEntity</code> is a spcification of requirement of your API, which states that <strong><em>&quot;my API requires
name inside query to function properly.&quot;</em></strong></p>
<h4><a class="header" href="#example-route-with-entity" id="example-route-with-entity">Example Route with Entity</a></h4>
<pre><code class="language-go">var myRoute = rubik.Route {
	Path: &quot;/myPath&quot;,
	Entity: MyEntity,
	Controller: myController,
}

// definition of myController
func myController(req *rubik.Request) {
	entity, _ := req.Entity.(*MyEntity)
	req.Respond(&quot;You have entered name as: &quot; + entity.Name)
}

// replace myRouter with Router of your choice
[myRouter].Add(myRoute)
</code></pre>
<p>Lets <strong>cURL</strong> it:</p>
<pre><code class="language-bash">curl &quot;http://localhost:$PORT/myPath?name=tom&quot;
</code></pre>
<blockquote>
<p><strong>Response</strong></p>
</blockquote>
<pre><code>You have entered name as: tom
</code></pre>
<h1><a class="header" href="#controllers" id="controllers">Controllers</a></h1>
<h1><a class="header" href="#lifecycle-of-rubik" id="lifecycle-of-rubik">Lifecycle of Rubik</a></h1>
<p>The <a href="./chapter_5.html">component lifecyle</a> of Rubik is arranged in such a way that the more error
prone and security dense components align at the top of the lifecycle.</p>
<p><img src="/rubik-lifecycle.png" alt="lifecycle" /></p>
<h1><a class="header" href="#-blocks-runtime-extensions" id="-blocks-runtime-extensions">📦 Blocks: Runtime Extensions</a></h1>
<p>Components that are independant of the core system is called as a block. Blocks can never depend
on a specific nature of the server yet provide extended functionality to your Rubik server.</p>
<p>It can be seen as plugin system of Rubik ecosystem, but -- it has some features that tie it to
the boot sequence of the Rubik's core thereby eventually making it part of the system.</p>
<h2><a class="header" href="#writing-a-block" id="writing-a-block">Writing a Block</a></h2>
<p>Writing a block is as simple as implementing a singl method, thet serves as the <code>main</code> func for
your extension. A <code>struct</code> is considered as a Rubik Block only if you implement the <code>OnAttach</code> method
of the <code>rubik.Block</code> interface.</p>
<p>So what does it look like?</p>
<h4><a class="header" href="#myawesomeblockgo" id="myawesomeblockgo"><code>&gt; myawesomeblock.go</code></a></h4>
<pre><code class="language-go">package awesome

import (
	&quot;fmt&quot;
	r &quot;github.com/rubikorg/rubik&quot;
)

type BlockAwesome struct{}

func (a BlockAwesome) OnAttach(app *r.App) error {
	// block code
	fmt.Println(&quot;awesome block is initialized!&quot;)
	return nil
}
</code></pre>
<p>There are 2 things that catches the eye:</p>
<ol>
<li><code>app</code> parameter - The app parameter is supplied to you by rubik which gives you limited access
to the implementer's server.</li>
</ol>
<p>!!! Note
This is not the Rubik instance itself, as this would be too big a vulnerability it supplies
you with only the functions that you need to build a block.</p>
<ol start="2">
<li><code>error</code> return statement - OnAttach is called first in the boot sequence by Rubik so if you
return an error the server will panic and not start, which is an intended workflow.</li>
</ol>
<p>!!! Quote
If the block can not even initialize properly, it can never function properly.</p>
<h2><a class="header" href="#attaching-a-block" id="attaching-a-block">Attaching a Block</a></h2>
<p>A block can never be known by the Rubik server until you attach it, it can be done by calling
<code>rubik.Attach</code> inside the <code>init</code> method of this block file.</p>
<p>Considering the above example:</p>
<h4><a class="header" href="#myawesomeblockgo-1" id="myawesomeblockgo-1"><code>&gt; myawesomeblock.go</code></a></h4>
<pre><code class="language-go">package awesome

import (
	&quot;fmt&quot;
	r &quot;github.com/rubikorg/rubik&quot;
)

type BlockAwesome struct{}

func (a BlockAwesome) OnAttach(app *r.App) error {
	// block code
	fmt.Println(&quot;awesome block is initialized!&quot;)
	return nil
}

func init() {
	r.Attach(&quot;myawesomeblock&quot;, BlockAwesome{})
}
</code></pre>
<p><code>rubik.Attach</code> takes in a <code>(name string, block rubik.Block)</code> as it's parameters.</p>
<h2><a class="header" href="#best-practices" id="best-practices">Best Practices</a></h2>
<p>Notice how we had initialized the block? By passing a raw string -- this can prove dangerous while
developers using this block try to Get your Block for usage.</p>
<ul>
<li>It is is always a good practise to declare a <code>BlockName</code> constant inside your block file.
This can prove very useful while <a href="">getting the block</a>.</li>
</ul>
<pre><code class="language-go">// BlockName is this block's name -- like so
// and pass it inside the Attach method
const BlockName = &quot;myawesomeblock&quot;
</code></pre>
<ul>
<li>Always Attach it inside the <code>init</code> method. Blocks are inherently separate components and is
designed in such a way too -- so why let developers Attach it separately inside their main file?</li>
</ul>
<h2><a class="header" href="#getting-a-block" id="getting-a-block">Getting a Block</a></h2>
<p>Developers can get your block while implementing their business logic from anywhere in the project.
Since Rubik is a singleton instance it maintaines a map of blocks by the name that you specify.</p>
<p>A very good example of this type of implementation is the <a href="/blocks/cors">CORS</a> block:</p>
<pre><code class="language-go">import (
    &quot;github.com/rubikorg/blocks/yourBlock&quot;
    r &quot;github.com/rubikorg/rubik&quot;
)

// notice how BlockName came in handy?
var yourBlock = r.GetBlock(yourBlock.BlockName)
</code></pre>
<p><code>r.GetBlock()</code> gets the Block by name, rubik knows that it's a Block <em>(as it satisfies the Block
interface)</em> but compiler just doesn't know which one <em>(yet ..generics please rant!!)</em> ..</p>
<p>!!! Note
There is no possible way that <code>r.GetBlock</code> returns any other Block because of the map and
unique key that it it maintains. So rest assured while coercing to your Block type.</p>
<h2><a class="header" href="#accessible-functions-from-blocks" id="accessible-functions-from-blocks">Accessible Functions from Blocks</a></h2>
<h3><a class="header" href="#decode" id="decode">Decode</a></h3>
<p><code>type: Function</code></p>
<p>Decode decodes the internal rubik server config into the struct that you provide. It returns
error if the config is not unmarshalable OR there if there is no config initialized by
the given name parameter. It is useful when you really want some configs to be present for
your block to work.</p>
<pre><code class="language-go">func (sb *App) Decode(name string, target interface{}) error {}
</code></pre>
<h3><a class="header" href="#config" id="config">Config</a></h3>
<p><code>type: Function</code></p>
<p>Config gets config by name</p>
<pre><code class="language-go">func (sb *App) Config(name string) interface{} {}
</code></pre>
<h3><a class="header" href="#currenturl" id="currenturl">CurrentURL</a></h3>
<p><code>type: String</code></p>
<p>It is the localhost prepended current URL of your Rubik server.</p>
<pre><code class="language-go">app.CurrentURL
</code></pre>
<h3><a class="header" href="#routetree" id="routetree">RouteTree</a></h3>
<p><code>type: Struct</code>
All The initialized Routes and their belongings such as <code>Entity</code>, <code>Description</code> etc.</p>
<pre><code class="language-go">app.RouteTree
</code></pre>
<blockquote>
<p><strong>Note</strong></p>
<p>A RouteTree is not initialized until boot sequence completes. If you want to make use of the
RouteTree you can use <code>rubik.AttachAfter()</code> which attaches your Block after the boot sequence
is complete</p>
</blockquote>
<h1><a class="header" href="#changelog" id="changelog">Changelog</a></h1>
<h2><a class="header" href="#v026" id="v026">v0.2.6</a></h2>
<ul>
<li>A <code>Route</code> now can have multiple <code>Guards</code></li>
<li>Added Validation Layer after Gurads, with <code>Assertion</code> type</li>
<li>Add support for <code>Claims</code> type which can be used as Authorization medium in JWT, Basic etc..</li>
<li>Support added for <code>ExtensionBlock</code> which can be used as blocks which does not require server to
run but perform operations depending upon server characteristic.</li>
</ul>
<pre><code class="language-bash">okrubik run --ext
</code></pre>
<p>runs the <code>ExtensionBlock</code>s attached to your server.</p>
<ul>
<li>Host and Port both of them are required from the <code>config</code> directory</li>
<li>Cleanup unused and unwanted functions</li>
<li>Dependency injection is now developer-facing</li>
</ul>
<h2><a class="header" href="#v020" id="v020">v0.2.0</a></h2>
<ul>
<li>Changes to Rubik’s Controller signature — Everything is a controller - <a href="https://github.com/rubikorg/rubik/pull/32">#32</a></li>
</ul>
<pre><code class="language-go">var r := rubik.Route{
	Path: “/”,
	Controller: indexCtl,
}

// === old method signature ===
// fund indexCtlOld(en interface{}) rubik.ByteResponse{
// 	return rubik.Success(&quot;Hello World&quot;)
// }

// === much cleaner and simple 0.2.0 method signature ===
func indexCtl(req *rubik.Request) {
	// rubik.Failure is now (req.Throw)
	req.Respond(“Hello World&quot;)
}
</code></pre>
<ul>
<li>Now supports <strong>interop</strong> with Go's stdlib -- Any Handler || HandlerFunc can be casted to Controller</li>
</ul>
<pre><code class="language-go">var r := rubik.Route{
	Path: “/”,
	Controller: rubik.UseHandlerFunc(indexHandlerFunc), // OR UseHandler() for handlers
}

func indexHandlerFunc(w http.ResponseWriter, r *http.Request) {
	fmt.Fprint(&amp;w, “Hello world&quot;)
}
</code></pre>
<ul>
<li><code>okrubik gen router ${name}</code> this command now parses ast properly and adds the new router import and its
invocation</li>
<li>There is a new method call <code>NewProbe()</code> which helps you with testing rubik.Router(s)</li>
<li>CLI is now migrated to cobra instead of vanilla <code>flag.Parse()</code> for scalability reasons -
<a href="https://github.com/rubikorg/okrubik/pull/5">#5</a></li>
<li>Improved API Documentation</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
