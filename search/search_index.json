{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rubik is a efficient, scalable micro-framework for writing REST client and server-side applications. It provides a pluggable layer of abstraction over `net/http` and enables automation of development environment through extensive tooling. Rubik aims to deliver similar experience on projects of different scale and keep support of existing Go's `net/http` interfaces for cross-compatibility. Quickstart Installation \uf0c1 Rubik comes with it's own generator CLI called okrubik . Copy and paste the below command to install the CLI tool. Shell : (Alpha) curl https://rubik.ashishshekar.com/install | sh Note okrubik is not supported for Windows yet. Although you can download and build the CLI for your platform from this repository. It is not tested with this release. Create Project \uf0c1 After your project is installed to the path you can easily create a Rubik project by running the create command: okrubik create You'll be presented with some questions before setting up your Rubik server. After you answer them a directory will be created with your project name. Running Project \uf0c1 You can run the project by using the run command: okrubik run You will see a chooser to run which of the projects in your Rubik workspace. After you choose server you can see your Rubik server running at PORT you had entered. You'll see a page like so: Success Congratulations on your Rubik project setup! You will have all the resources at your disposal for quickly writing REST APIs in that page. Framework Documentation \uf0c1 The framework is new and needs many documentation that needs to be added. The current documentation of Rubik framework can be found here . Disclaimer! \uf0c1 This project is still in alpha stage. Meaning, that it should not be used for writing complex and information sensitive servers -- \"yet\". As this project is made support the needs of an upcoming product that is due to be launched this year, it'll receive huge updates and in-time it will become rock solid! However... \uf0c1 This alpha release of Rubik can be used for quick prototying and proof-of-concept servers for your ideas.","title":"Home"},{"location":"#installation","text":"Rubik comes with it's own generator CLI called okrubik . Copy and paste the below command to install the CLI tool. Shell : (Alpha) curl https://rubik.ashishshekar.com/install | sh Note okrubik is not supported for Windows yet. Although you can download and build the CLI for your platform from this repository. It is not tested with this release.","title":"Installation"},{"location":"#create-project","text":"After your project is installed to the path you can easily create a Rubik project by running the create command: okrubik create You'll be presented with some questions before setting up your Rubik server. After you answer them a directory will be created with your project name.","title":"Create Project"},{"location":"#running-project","text":"You can run the project by using the run command: okrubik run You will see a chooser to run which of the projects in your Rubik workspace. After you choose server you can see your Rubik server running at PORT you had entered. You'll see a page like so: Success Congratulations on your Rubik project setup! You will have all the resources at your disposal for quickly writing REST APIs in that page.","title":"Running Project"},{"location":"#framework-documentation","text":"The framework is new and needs many documentation that needs to be added. The current documentation of Rubik framework can be found here .","title":"Framework Documentation"},{"location":"#disclaimer","text":"This project is still in alpha stage. Meaning, that it should not be used for writing complex and information sensitive servers -- \"yet\". As this project is made support the needs of an upcoming product that is due to be launched this year, it'll receive huge updates and in-time it will become rock solid!","title":"Disclaimer!"},{"location":"#however","text":"This alpha release of Rubik can be used for quick prototying and proof-of-concept servers for your ideas.","title":"However..."},{"location":"blog/","text":"Rubik Blog! \uf0c1 Rubik is not just a side project \uf0c1 Author: Ashish Shekar | 2020-02-02 Desctiption ...","title":"Rubik Blog!"},{"location":"blog/#rubik-blog","text":"","title":"Rubik Blog!"},{"location":"blog/#rubik-is-not-just-a-side-project","text":"Author: Ashish Shekar | 2020-02-02 Desctiption ...","title":"Rubik is not just a side project"},{"location":"getting-started/","text":"Getting Started \uf0c1 This guide is to get you up and running with the latest Rubik framework release. Let's get started with the prerequisites. What is Rubik? \uf0c1 Prerequisites \uf0c1 Create a New Rubik Project \uf0c1 Starting the Server \uf0c1 Creating a Blog \uf0c1","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"This guide is to get you up and running with the latest Rubik framework release. Let's get started with the prerequisites.","title":"Getting Started"},{"location":"getting-started/#what-is-rubik","text":"","title":"What is Rubik?"},{"location":"getting-started/#prerequisites","text":"","title":"Prerequisites"},{"location":"getting-started/#create-a-new-rubik-project","text":"","title":"Create a New Rubik Project"},{"location":"getting-started/#starting-the-server","text":"","title":"Starting the Server"},{"location":"getting-started/#creating-a-blog","text":"","title":"Creating a Blog"},{"location":"about/community/","text":"Rubik Community \uf0c1 Join the community of rubik to discuss more about the features, development and contribution of rubik-server, client and cli. Follow Twitter \uf0c1 You can follow the author or rubikorg on twitter for updates and your views on rubik.","title":"Rubik Community"},{"location":"about/community/#rubik-community","text":"Join the community of rubik to discuss more about the features, development and contribution of rubik-server, client and cli.","title":"Rubik Community"},{"location":"about/community/#follow-twitter","text":"You can follow the author or rubikorg on twitter for updates and your views on rubik.","title":"Follow Twitter"},{"location":"about/contributing/","text":"Contributing to Rubik \uf0c1 Rubik was created from the inspiration of many frameworks like Django, Loopback, Flask etc. The idea here is to quickly get started with building web client-server apps in Go and have fun while building it. Identifying Problems \uf0c1 If you come accross some issues and problems that is part of rubik and it is not working the way it should be, feel free to create an issue on our GitHub repository. This will let us know about your concerns and we can implement a solution to fix your problem. Submitting Proposals \uf0c1 Having trouble with some feature or want to implement your own? You can simply submit a proposal by creating an issue on the Github repository and add Proposal: in front of your issue title. We really like Go's way of including features and fixing existing features and would almost like to follow the same process. This will ping all the maintainers on project on Discord as well as lets us know that there is a new proposal coming in. Creating Pull Requests \uf0c1 You think that the current codebase or structure can be improved and make rubik even better? Create a pull-request with your changes and tag @codekidX . If our goals align and requirements meet, you have contributed to the world's awesome framework || if not make us understand why your solution trumps our thinking and we can implement a nearest possible solution that makes all of us happy. Spreading The Word \uf0c1 Like working with rubik? You can spread the word to many of your colleagues and fellow gophers so that the rubik can be the best-of-the-best HTTP framework. Quote It is not about how many people use rubik, it is about how many people using it are happy that matters the most. Helping With Docs \uf0c1 As a rubik user docs is the most vital building block of the community, you can visit the below Edit on Github link to contribute in making the best documentation there is.","title":"Contribute on GitHub"},{"location":"about/contributing/#contributing-to-rubik","text":"Rubik was created from the inspiration of many frameworks like Django, Loopback, Flask etc. The idea here is to quickly get started with building web client-server apps in Go and have fun while building it.","title":"Contributing to Rubik"},{"location":"about/contributing/#identifying-problems","text":"If you come accross some issues and problems that is part of rubik and it is not working the way it should be, feel free to create an issue on our GitHub repository. This will let us know about your concerns and we can implement a solution to fix your problem.","title":"Identifying Problems"},{"location":"about/contributing/#submitting-proposals","text":"Having trouble with some feature or want to implement your own? You can simply submit a proposal by creating an issue on the Github repository and add Proposal: in front of your issue title. We really like Go's way of including features and fixing existing features and would almost like to follow the same process. This will ping all the maintainers on project on Discord as well as lets us know that there is a new proposal coming in.","title":"Submitting Proposals"},{"location":"about/contributing/#creating-pull-requests","text":"You think that the current codebase or structure can be improved and make rubik even better? Create a pull-request with your changes and tag @codekidX . If our goals align and requirements meet, you have contributed to the world's awesome framework || if not make us understand why your solution trumps our thinking and we can implement a nearest possible solution that makes all of us happy.","title":"Creating Pull Requests"},{"location":"about/contributing/#spreading-the-word","text":"Like working with rubik? You can spread the word to many of your colleagues and fellow gophers so that the rubik can be the best-of-the-best HTTP framework. Quote It is not about how many people use rubik, it is about how many people using it are happy that matters the most.","title":"Spreading The Word"},{"location":"about/contributing/#helping-with-docs","text":"As a rubik user docs is the most vital building block of the community, you can visit the below Edit on Github link to contribute in making the best documentation there is.","title":"Helping With Docs"},{"location":"about/introduction/","text":"Prologue \uf0c1 Rubik aims to provide the tools and programmable APIs needed to quickly handle your server-side needs. Rubik has a robust layer of Go's reflection supporting the whole framework and provide many simple high-level APIs for handling complex tasks. The directory structure of Rubik is minimal but effective. Among other things, Rubik will serve as a great replacement for your server-side needs and will in turn provide many pluggable blocks. Goals \uf0c1 = Keep a small footprint = Provide Block (extenstion) APIs that can basically support any integration = Support this micro-framework with extensive tooling, which is to be focused always. Writing APIs quickly is of utmost priority. Concerns \uf0c1 Apart from being @my largest project in terms of sheer code size I think it needs to be trimmed down in the upcoming releases. In order to stay small it must let go of some features in any of the following alpha releases.","title":"Introduction"},{"location":"about/introduction/#prologue","text":"Rubik aims to provide the tools and programmable APIs needed to quickly handle your server-side needs. Rubik has a robust layer of Go's reflection supporting the whole framework and provide many simple high-level APIs for handling complex tasks. The directory structure of Rubik is minimal but effective. Among other things, Rubik will serve as a great replacement for your server-side needs and will in turn provide many pluggable blocks.","title":"Prologue"},{"location":"about/introduction/#goals","text":"= Keep a small footprint = Provide Block (extenstion) APIs that can basically support any integration = Support this micro-framework with extensive tooling, which is to be focused always. Writing APIs quickly is of utmost priority.","title":"Goals"},{"location":"about/introduction/#concerns","text":"Apart from being @my largest project in terms of sheer code size I think it needs to be trimmed down in the upcoming releases. In order to stay small it must let go of some features in any of the following alpha releases.","title":"Concerns"},{"location":"about/release-notes/","text":"Release Notes \uf0c1 v0.1 \uf0c1 May 29 2020 \uf0c1 Basic structure setup and conventions okrubik CLI rubik-client - alpha v0.2 (TBD) \uf0c1 v0.3 (TBD) \uf0c1 Milestone: Rubik One \uf0c1","title":"Release Notes"},{"location":"about/release-notes/#release-notes","text":"","title":"Release Notes"},{"location":"about/release-notes/#v01","text":"","title":"v0.1"},{"location":"about/release-notes/#may-29-2020","text":"Basic structure setup and conventions okrubik CLI rubik-client - alpha","title":"May 29 2020"},{"location":"about/release-notes/#v02-tbd","text":"","title":"v0.2 (TBD)"},{"location":"about/release-notes/#v03-tbd","text":"","title":"v0.3 (TBD)"},{"location":"about/release-notes/#milestone-rubik-one","text":"","title":"Milestone: Rubik One"},{"location":"blocks/cors/","text":"Cors Block \uf0c1 source: [ /blocks/cors/cors.go ] Options \uf0c1 The JSON tags represents the configuration equivalents as shown here . AllowedOrigins []string `json: origins ` AllowedMethods []string `json: methods ` AllowAllOrigins bool `json: allOrigins ` AllowAllMethods bool `json: allMethods ` AllowCredentials bool `json: allowCredentials ` Steps \uf0c1 Add your cors config to default.toml inside config directory [cors] origins = [ mywebsite.com ] allMethods = true Add this import to the main.go file import ( _ github.com/rubikorg/blocks/cors ) Use cors middleware in your Routes import ( github.com/rubikorg/blocks/cors r github.com/rubikorg/rubik ) // git middeware from cors block var corsMw = r.GetBlock(cors.BlockName).(cors.BlockCors).MW var myRoute = r.Route{ Path: / , Middlewares: []r.Middleware{ corsMw(), // like this }, } Overriding CORS \uf0c1 For A Specific Route you can override the global Cors Options just by passing your own cors options to the middleware. import ( github.com/rubikorg/blocks/cors r github.com/rubikorg/rubik ) var corsMw = r.GetBlock(cors.BlockName).(cors.BlockCors).MW var copts = cors.Options{ AllowedOrigins: []string{ mynewwebsite.com }, } var myRoute = r.Route{ Path: / , Middlewares: []r.Middleware{ corsMW(copts), // override like this }, }","title":"Cors Block"},{"location":"blocks/cors/#cors-block","text":"source: [ /blocks/cors/cors.go ]","title":"Cors Block"},{"location":"blocks/cors/#options","text":"The JSON tags represents the configuration equivalents as shown here . AllowedOrigins []string `json: origins ` AllowedMethods []string `json: methods ` AllowAllOrigins bool `json: allOrigins ` AllowAllMethods bool `json: allMethods ` AllowCredentials bool `json: allowCredentials `","title":"Options"},{"location":"blocks/cors/#steps","text":"Add your cors config to default.toml inside config directory [cors] origins = [ mywebsite.com ] allMethods = true Add this import to the main.go file import ( _ github.com/rubikorg/blocks/cors ) Use cors middleware in your Routes import ( github.com/rubikorg/blocks/cors r github.com/rubikorg/rubik ) // git middeware from cors block var corsMw = r.GetBlock(cors.BlockName).(cors.BlockCors).MW var myRoute = r.Route{ Path: / , Middlewares: []r.Middleware{ corsMw(), // like this }, }","title":"Steps"},{"location":"blocks/cors/#overriding-cors","text":"For A Specific Route you can override the global Cors Options just by passing your own cors options to the middleware. import ( github.com/rubikorg/blocks/cors r github.com/rubikorg/rubik ) var corsMw = r.GetBlock(cors.BlockName).(cors.BlockCors).MW var copts = cors.Options{ AllowedOrigins: []string{ mynewwebsite.com }, } var myRoute = r.Route{ Path: / , Middlewares: []r.Middleware{ corsMW(copts), // override like this }, }","title":"Overriding CORS"},{"location":"blocks/healthcheck/","text":"Health Check Block \uf0c1 source: [ /blocks/healthcheck/health.go ] Steps \uf0c1 Add this import to main.go file import ( _ github.com/rubikorg/blocks/healthcheck ) [Optional] Add custom path for your health check through config/default.toml [healthcheck] path = momos Done!","title":"Health Check Block"},{"location":"blocks/healthcheck/#health-check-block","text":"source: [ /blocks/healthcheck/health.go ]","title":"Health Check Block"},{"location":"blocks/healthcheck/#steps","text":"Add this import to main.go file import ( _ github.com/rubikorg/blocks/healthcheck ) [Optional] Add custom path for your health check through config/default.toml [healthcheck] path = momos Done!","title":"Steps"},{"location":"blocks/httplogger/","text":"HTTPLogger Block \uf0c1 source: [ /blocks/logger/httplogger.go ] Steps \uf0c1 Add this import to your main.go file import ( _ github.com/rubikorg/blocks/logger ) Done! \uf0c1","title":"HTTPLogger Block"},{"location":"blocks/httplogger/#httplogger-block","text":"source: [ /blocks/logger/httplogger.go ]","title":"HTTPLogger Block"},{"location":"blocks/httplogger/#steps","text":"Add this import to your main.go file import ( _ github.com/rubikorg/blocks/logger )","title":"Steps"},{"location":"blocks/httplogger/#done","text":"","title":"Done!"},{"location":"blocks/swagger/","text":"Swagger Block \uf0c1 source: [ /blocks/swagger/swagger.go ] Steps \uf0c1 Add Swagger Information about your server into config/default.toml file: [swagger] title = my rubik server description = this is my awesome rubik server version = 1.0.1 termsOfService = http://www.apache.org/licenses/LICENSE-2.0.html Add this to main.go of your rubik server import ( _ github.com/rubikorg/blocks/swagger ) Go to SERVER_URL/rubik/docs - replace SERVER_URL with your rubik server Base URL. Thats it! \uf0c1","title":"Swagger Block"},{"location":"blocks/swagger/#swagger-block","text":"source: [ /blocks/swagger/swagger.go ]","title":"Swagger Block"},{"location":"blocks/swagger/#steps","text":"Add Swagger Information about your server into config/default.toml file: [swagger] title = my rubik server description = this is my awesome rubik server version = 1.0.1 termsOfService = http://www.apache.org/licenses/LICENSE-2.0.html Add this to main.go of your rubik server import ( _ github.com/rubikorg/blocks/swagger ) Go to SERVER_URL/rubik/docs - replace SERVER_URL with your rubik server Base URL.","title":"Steps"},{"location":"blocks/swagger/#thats-it","text":"","title":"Thats it!"},{"location":"essentials/apis/","text":"APIs \uf0c1 Templating \uf0c1 The Rubik APIs for using Go's templating engine which makes it easier for creating REST APIs. Render \uf0c1 type: Function Render returns a mixin holding the data to be rendered on the web page or sent over the wire. import r github.com/rubikorg/rubik func myCtl(en interface{}) r.ByteResponse { return r.Render(r.Type.HTML, en, mypage.html ) } Storage Container \uf0c1 type: Struct StorageContainer is abstracted struct to access your storage files. It can access of remove a whole container. Container corresponds to a single directory in your storage folder and will have access to files only inside this container/directory. GetStorageContainers \uf0c1 type: Function GetStorageContainers returns the names of containers present in your storage/ folder. You can access them by calling Storage.Access API and use Get or Put to work with your files. import r github.com/rubikorg/rubik containers := r.GetStorageContainers() for _, name := range containers { // do something with these containers } Access \uf0c1 type: Function Access a FileStore from your StorageContainer. It can be viewed as accessing a specific folder inside your storage/ folder and performing operations inside of that folder. fileStore, err := r.Storage.Access( paymentFiles ) if err != nil { // cannot access this container } Remove \uf0c1 type: Function Remove a FileStore from your StorageContainer. Removing a FileStore will remove all the files inside the FileStore. err := r.Storage.Remove( paymentFiles ) if err != nil { // error occured while deleting container } FileStore \uf0c1 type: Struct FileStore lets you perform CRUD on files of StorageContainer. FileStore returns the name of container you are accessing by Name field. Has \uf0c1 type: Function Has checks if the file by given name is present inside this FileStore. if fileStore.Has( file.txt ) { // do something } Get \uf0c1 type: Function Get a file from this FileStore, returs byte slice. fileContents := fileStore.Get( file.txt ) if fileContents == nil { // did not find file } Put \uf0c1 type: Function Put a file inside this FileStore given the content as parameter. err := fileStore.Put( file.txt , contents) if err != nil { // error occured while writing to disk } Delete \uf0c1 type: Function Delete a file from the FileStore, returns error. err := fileStore.Delete( file.txt ) if err != nil { // error occured while deleting }","title":"Core"},{"location":"essentials/apis/#apis","text":"","title":"APIs"},{"location":"essentials/apis/#templating","text":"The Rubik APIs for using Go's templating engine which makes it easier for creating REST APIs.","title":"Templating"},{"location":"essentials/apis/#render","text":"type: Function Render returns a mixin holding the data to be rendered on the web page or sent over the wire. import r github.com/rubikorg/rubik func myCtl(en interface{}) r.ByteResponse { return r.Render(r.Type.HTML, en, mypage.html ) }","title":"Render"},{"location":"essentials/apis/#storage-container","text":"type: Struct StorageContainer is abstracted struct to access your storage files. It can access of remove a whole container. Container corresponds to a single directory in your storage folder and will have access to files only inside this container/directory.","title":"Storage Container"},{"location":"essentials/apis/#getstoragecontainers","text":"type: Function GetStorageContainers returns the names of containers present in your storage/ folder. You can access them by calling Storage.Access API and use Get or Put to work with your files. import r github.com/rubikorg/rubik containers := r.GetStorageContainers() for _, name := range containers { // do something with these containers }","title":"GetStorageContainers"},{"location":"essentials/apis/#access","text":"type: Function Access a FileStore from your StorageContainer. It can be viewed as accessing a specific folder inside your storage/ folder and performing operations inside of that folder. fileStore, err := r.Storage.Access( paymentFiles ) if err != nil { // cannot access this container }","title":"Access"},{"location":"essentials/apis/#remove","text":"type: Function Remove a FileStore from your StorageContainer. Removing a FileStore will remove all the files inside the FileStore. err := r.Storage.Remove( paymentFiles ) if err != nil { // error occured while deleting container }","title":"Remove"},{"location":"essentials/apis/#filestore","text":"type: Struct FileStore lets you perform CRUD on files of StorageContainer. FileStore returns the name of container you are accessing by Name field.","title":"FileStore"},{"location":"essentials/apis/#has","text":"type: Function Has checks if the file by given name is present inside this FileStore. if fileStore.Has( file.txt ) { // do something }","title":"Has"},{"location":"essentials/apis/#get","text":"type: Function Get a file from this FileStore, returs byte slice. fileContents := fileStore.Get( file.txt ) if fileContents == nil { // did not find file }","title":"Get"},{"location":"essentials/apis/#put","text":"type: Function Put a file inside this FileStore given the content as parameter. err := fileStore.Put( file.txt , contents) if err != nil { // error occured while writing to disk }","title":"Put"},{"location":"essentials/apis/#delete","text":"type: Function Delete a file from the FileStore, returns error. err := fileStore.Delete( file.txt ) if err != nil { // error occured while deleting }","title":"Delete"},{"location":"essentials/blocks/","text":"List of Available Blocks \uf0c1 Take a look at some blocks that the @author has made until we get some more contributions: Simple HTTPLogger Block - A Rubik block for logging request path and response times. HealthCheck Block - Readily appends a route for health check services like kubernetes etc.. About Blocks \uf0c1 Components that are independant of the core system is called as a block. Blocks can never depend on a specific nature of the server yet provide extended functionality to your Rubik server. It can be seen as plugin system of Rubik ecosystem, but -- it has some features that tie it to the boot sequence of the Rubik's core thereby eventually making it part of the system. Writing a Block \uf0c1 Writing a block is as simple as implementing a singl method, thet serves as the main func for your extension. A struct is considered as a Rubik Block only if you implement the OnAttach method of the rubik.Block interface. So what does it look like? :: myawesomeblock.go package awesome import ( fmt r github.com/rubikorg/rubik ) type BlockAwesome struct{} func (a BlockAwesome) OnAttach(app *r.App) error { // block code fmt.Println( awesome block is initialized! ) return nil } There are 2 things that catches the eye: app parameter - The app parameter is supplied to you by rubik which gives you limited access to the implementer's server. Note This is not the Rubik instance itself, as this would be too big a vulnerability it supplies you with only the functions that you need to build a block. error return statement - OnAttach is called first in the boot sequence by Rubik so if you return an error the server will panic and not start, which is an intended workflow. Quote If the block can not even initialize properly, it can never function properly. Attaching a Block \uf0c1 A block can never be known by the Rubik server until you attach it, it can be done by calling rubik.Attach inside the init method of this block file. Considering the above example: :: myawesomeblock.go package awesome import ( fmt r github.com/rubikorg/rubik ) type BlockAwesome struct{} func (a BlockAwesome) OnAttach(app *r.App) error { // block code fmt.Println( awesome block is initialized! ) return nil } func init() { r.Attach( myawesomeblock , BlockAwesome{}) } rubik.Attach takes in a (name string, block rubik.Block) as it's parameters. Best Practices \uf0c1 Notice how we had initialized the block? By passing a raw string -- this can prove dangerous while developers using this block try to Get your Block for usage. It is is always a good practise to declare a BlockName constant inside your block file. This can prove very useful while getting the block . // BlockName is this block's name -- like so // and pass it inside the Attach method const BlockName = myawesomeblock Always Attach it inside the init method. Blocks are inherently separate components and is designed in such a way too -- so why let developers Attach it separately inside their main file? Getting a Block \uf0c1 Developers can get your block while implementing their business logic from anywhere in the project. Since Rubik is a singleton instance it maintaines a map of blocks by the name that you specify. A very good example of this type of implementation is the CORS block: import ( github.com/rubikorg/blocks/yourBlock r github.com/rubikorg/rubik ) // notice how BlockName came in handy? var yourBlock = r.GetBlock(yourBlock.BlockName) r.GetBlock() gets the Block by name, rubik knows that it's a Block (as it satisfies the Block interface) but compiler just doesn't know which one (yet ..generics please rant!!) .. Note There is no possible way that r.GetBlock returns any other Block because of the map and unique key that it it maintains. So rest assured while coercing to your Block type. Accessible APIs by Blocks \uf0c1 Decode \uf0c1 type: Function Decode decodes the internal rubik server config into the struct that you provide. It returns error if the config is not unmarshalable OR there if there is no config initialized by the given name parameter. It is useful when you really want some configs to be present for your block to work. func (sb *App) Decode(name string, target interface{}) error {} Config \uf0c1 type: Function Config gets config by name func (sb *App) Config(name string) interface{} {} CurrentURL \uf0c1 type: String It is the localhost prepended current URL of your Rubik server. app.CurrentURL RouteTree \uf0c1 type: Struct All The initialized Routes and their belongings such as Entity , Description etc. app.RouteTree Note A RouteTree is not initialized until boot sequence completes. If you want to make use of the RouteTree you can use rubik.AttachAfter() which attaches your Block after the boot sequence is complete.","title":"Blocks"},{"location":"essentials/blocks/#list-of-available-blocks","text":"Take a look at some blocks that the @author has made until we get some more contributions: Simple HTTPLogger Block - A Rubik block for logging request path and response times. HealthCheck Block - Readily appends a route for health check services like kubernetes etc..","title":"List of Available Blocks"},{"location":"essentials/blocks/#about-blocks","text":"Components that are independant of the core system is called as a block. Blocks can never depend on a specific nature of the server yet provide extended functionality to your Rubik server. It can be seen as plugin system of Rubik ecosystem, but -- it has some features that tie it to the boot sequence of the Rubik's core thereby eventually making it part of the system.","title":"About Blocks"},{"location":"essentials/blocks/#writing-a-block","text":"Writing a block is as simple as implementing a singl method, thet serves as the main func for your extension. A struct is considered as a Rubik Block only if you implement the OnAttach method of the rubik.Block interface. So what does it look like? :: myawesomeblock.go package awesome import ( fmt r github.com/rubikorg/rubik ) type BlockAwesome struct{} func (a BlockAwesome) OnAttach(app *r.App) error { // block code fmt.Println( awesome block is initialized! ) return nil } There are 2 things that catches the eye: app parameter - The app parameter is supplied to you by rubik which gives you limited access to the implementer's server. Note This is not the Rubik instance itself, as this would be too big a vulnerability it supplies you with only the functions that you need to build a block. error return statement - OnAttach is called first in the boot sequence by Rubik so if you return an error the server will panic and not start, which is an intended workflow. Quote If the block can not even initialize properly, it can never function properly.","title":"Writing a Block"},{"location":"essentials/blocks/#attaching-a-block","text":"A block can never be known by the Rubik server until you attach it, it can be done by calling rubik.Attach inside the init method of this block file. Considering the above example: :: myawesomeblock.go package awesome import ( fmt r github.com/rubikorg/rubik ) type BlockAwesome struct{} func (a BlockAwesome) OnAttach(app *r.App) error { // block code fmt.Println( awesome block is initialized! ) return nil } func init() { r.Attach( myawesomeblock , BlockAwesome{}) } rubik.Attach takes in a (name string, block rubik.Block) as it's parameters.","title":"Attaching a Block"},{"location":"essentials/blocks/#best-practices","text":"Notice how we had initialized the block? By passing a raw string -- this can prove dangerous while developers using this block try to Get your Block for usage. It is is always a good practise to declare a BlockName constant inside your block file. This can prove very useful while getting the block . // BlockName is this block's name -- like so // and pass it inside the Attach method const BlockName = myawesomeblock Always Attach it inside the init method. Blocks are inherently separate components and is designed in such a way too -- so why let developers Attach it separately inside their main file?","title":"Best Practices"},{"location":"essentials/blocks/#getting-a-block","text":"Developers can get your block while implementing their business logic from anywhere in the project. Since Rubik is a singleton instance it maintaines a map of blocks by the name that you specify. A very good example of this type of implementation is the CORS block: import ( github.com/rubikorg/blocks/yourBlock r github.com/rubikorg/rubik ) // notice how BlockName came in handy? var yourBlock = r.GetBlock(yourBlock.BlockName) r.GetBlock() gets the Block by name, rubik knows that it's a Block (as it satisfies the Block interface) but compiler just doesn't know which one (yet ..generics please rant!!) .. Note There is no possible way that r.GetBlock returns any other Block because of the map and unique key that it it maintains. So rest assured while coercing to your Block type.","title":"Getting a Block"},{"location":"essentials/blocks/#accessible-apis-by-blocks","text":"","title":"Accessible APIs by Blocks"},{"location":"essentials/blocks/#decode","text":"type: Function Decode decodes the internal rubik server config into the struct that you provide. It returns error if the config is not unmarshalable OR there if there is no config initialized by the given name parameter. It is useful when you really want some configs to be present for your block to work. func (sb *App) Decode(name string, target interface{}) error {}","title":"Decode"},{"location":"essentials/blocks/#config","text":"type: Function Config gets config by name func (sb *App) Config(name string) interface{} {}","title":"Config"},{"location":"essentials/blocks/#currenturl","text":"type: String It is the localhost prepended current URL of your Rubik server. app.CurrentURL","title":"CurrentURL"},{"location":"essentials/blocks/#routetree","text":"type: Struct All The initialized Routes and their belongings such as Entity , Description etc. app.RouteTree Note A RouteTree is not initialized until boot sequence completes. If you want to make use of the RouteTree you can use rubik.AttachAfter() which attaches your Block after the boot sequence is complete.","title":"RouteTree"},{"location":"essentials/configuration/","text":"Configuration \uf0c1 Configuration is a living-breathing component of the Rubik server. It is very much a part of the system as core itself. Configs are used to setup your system as well as the extensions. Blocks (extensions) configuration also lives inside your code and Rubik exposes them to external functionalities. Internal uses such as port inside your default.toml let's Rubik know which port to run the server on. Loading Configuration \uf0c1 Loading a config and maintaining is all taken care of by Rubik internal system and it's config manager. Project config is the global config that your project can use in any routes. For example: You have a firebase key that you want in a route for accessing FCM maybe. We define this common key inside default.toml : [firebase] secret = tis-is-cigerette With this ProjectConfig struct inside config/decl.go type FirebaseConfig struct { Secret string } type ProjectConfig struct { Firebase FirebaseConfig } We load it in our main.go file: func main() { var conf config.ProjectConfig err := rubik.Load( conf) } Accessing Configuration \uf0c1 We can access our ProjectConfig from any controller by calling r.GetConfig() : import ( r github.com/rubikorg/rubik cfg {myModule}/cmd/server/config ) func firebaseMsgCtl(en interface{}) r.ByteResponse { conf := r.GetConfig().(cfg.ProjectConfig) // access key sendFCM(conf.Firebase.Secret, my message is: lol ) return r.Success( lol ) }","title":"Configuration"},{"location":"essentials/configuration/#configuration","text":"Configuration is a living-breathing component of the Rubik server. It is very much a part of the system as core itself. Configs are used to setup your system as well as the extensions. Blocks (extensions) configuration also lives inside your code and Rubik exposes them to external functionalities. Internal uses such as port inside your default.toml let's Rubik know which port to run the server on.","title":"Configuration"},{"location":"essentials/configuration/#loading-configuration","text":"Loading a config and maintaining is all taken care of by Rubik internal system and it's config manager. Project config is the global config that your project can use in any routes. For example: You have a firebase key that you want in a route for accessing FCM maybe. We define this common key inside default.toml : [firebase] secret = tis-is-cigerette With this ProjectConfig struct inside config/decl.go type FirebaseConfig struct { Secret string } type ProjectConfig struct { Firebase FirebaseConfig } We load it in our main.go file: func main() { var conf config.ProjectConfig err := rubik.Load( conf) }","title":"Loading Configuration"},{"location":"essentials/configuration/#accessing-configuration","text":"We can access our ProjectConfig from any controller by calling r.GetConfig() : import ( r github.com/rubikorg/rubik cfg {myModule}/cmd/server/config ) func firebaseMsgCtl(en interface{}) r.ByteResponse { conf := r.GetConfig().(cfg.ProjectConfig) // access key sendFCM(conf.Firebase.Secret, my message is: lol ) return r.Success( lol ) }","title":"Accessing Configuration"},{"location":"essentials/core-concepts/","text":"Project Structure \uf0c1 File/Folder Purpose main.go The entrypoint of your Rubik server","title":"Project Structure"},{"location":"essentials/core-concepts/#project-structure","text":"File/Folder Purpose main.go The entrypoint of your Rubik server","title":"Project Structure"},{"location":"essentials/testing-your-sketch/","text":"Rubik Test Suite \uf0c1 Rubik comes with it's own test suite to make it easier for developers to write tests. In order to wite a test you take advantage of your Entity Abstraction. import ( yourpackage/routes yourpackage/entity github.com/okrubik/rubik ) func init() { var config map[string]interface{} routes.Import() } func TestOrderRoute(t *testing.T) { en := entity.OrderEntity{ OrderId: 1, } req := rubik.Test.Mock() req.Header.Set( Authorization , blahblah ) resp, err := req.Test( /order , en) if !resp.Success { t.Errorf(resp.Message) } }","title":"Rubik Test Suite"},{"location":"essentials/testing-your-sketch/#rubik-test-suite","text":"Rubik comes with it's own test suite to make it easier for developers to write tests. In order to wite a test you take advantage of your Entity Abstraction. import ( yourpackage/routes yourpackage/entity github.com/okrubik/rubik ) func init() { var config map[string]interface{} routes.Import() } func TestOrderRoute(t *testing.T) { en := entity.OrderEntity{ OrderId: 1, } req := rubik.Test.Mock() req.Header.Set( Authorization , blahblah ) resp, err := req.Test( /order , en) if !resp.Success { t.Errorf(resp.Message) } }","title":"Rubik Test Suite"},{"location":"essentials/tooling/","text":"Tooling \uf0c1 Commands \uf0c1 create \uf0c1 Creates a new Rubik workspace and generates the boilerplate code for Rubik server. Usage: okrubik create gen \uf0c1 Generate (gen) command generates components of Rubik server and binds them with the existing components. There are currently 2 subcommands for this command: okrubik gen bin {name} - This command generates a new binary/service/app inside your same Rubik workspace. It is generated inside the cmd folder as a generic practise and also is accessible by commands such as run . okrubik gen router {name} - This command generates a new router folder with the index route right out of the box for you run \uf0c1 Run command runs your binary/service/app inside your Rubik workspace. It can access all the services named and present inside app array inside rubik.toml file. Some other functionalities are watch flag that let's run command watch for file changes inside the binary folder and then restart the server gracefully. help \uf0c1 Let's you see the available commands of the CLI.","title":"Tooling"},{"location":"essentials/tooling/#tooling","text":"","title":"Tooling"},{"location":"essentials/tooling/#commands","text":"","title":"Commands"},{"location":"essentials/tooling/#create","text":"Creates a new Rubik workspace and generates the boilerplate code for Rubik server. Usage: okrubik create","title":"create"},{"location":"essentials/tooling/#gen","text":"Generate (gen) command generates components of Rubik server and binds them with the existing components. There are currently 2 subcommands for this command: okrubik gen bin {name} - This command generates a new binary/service/app inside your same Rubik workspace. It is generated inside the cmd folder as a generic practise and also is accessible by commands such as run . okrubik gen router {name} - This command generates a new router folder with the index route right out of the box for you","title":"gen"},{"location":"essentials/tooling/#run","text":"Run command runs your binary/service/app inside your Rubik workspace. It can access all the services named and present inside app array inside rubik.toml file. Some other functionalities are watch flag that let's run command watch for file changes inside the binary folder and then restart the server gracefully.","title":"run"},{"location":"essentials/tooling/#help","text":"Let's you see the available commands of the CLI.","title":"help"}]}